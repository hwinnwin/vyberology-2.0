/**
 * A3 Core Codegen - Primary Implementation
 *
 * Deterministic code generation from manifest.
 * Uses template-based approach with string interpolation.
 *
 * Owner: B-01 (A3 Owner) - Limn Prime Code Master
 */

import {
  CodegenConfig,
  CodegenOutput,
  GeneratedFile,
  Manifest,
  ThresholdConfig,
  WeightConfig,
  MetricConfig
} from './types';
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

const VERSION = '1.0.0';
const GENERATOR = 'a3-primary';

/**
 * Generate code from manifest
 *
 * A3 APPROACH: Template-based generation with direct string building
 * - Parse YAML manifest
 * - Generate TypeScript types from schema
 * - Generate constants from config values
 * - Generate validators from constraints
 * - Deterministic output guaranteed
 */
export async function generate(config: CodegenConfig): Promise<CodegenOutput> {
  const startTime = Date.now();

  // Parse manifest
  const manifest = await parseManifest(config.manifestPath);
  const manifestHash = generateHash(JSON.stringify(manifest));

  // Generate files
  const files: GeneratedFile[] = [];

  // 1. Generate types
  files.push(generateTypes(manifest));

  // 2. Generate constants
  files.push(generateConstants(manifest));

  // 3. Generate validators
  files.push(generateValidators(manifest));

  // 4. Generate config runtime
  files.push(generateConfig(manifest));

  // 5. Generate barrel index
  files.push(generateIndex(files));

  const output: CodegenOutput = {
    files,
    metadata: {
      timestamp: new Date().toISOString(),
      version: VERSION,
      manifestHash,
      durationMs: Date.now() - startTime,
      generator: GENERATOR,
      fileCount: files.length
    },
    hash: ''
  };

  output.hash = generateOutputHash(output);

  return output;
}

/**
 * Parse manifest from YAML file
 */
async function parseManifest(manifestPath: string): Promise<Manifest> {
  // For now, use a simple YAML parser approach
  // In production, would use js-yaml
  const content = fs.readFileSync(path.resolve(manifestPath), 'utf-8');
  return parseYamlSimple(content);
}

/**
 * Simple YAML parser for manifest structure
 * A3 approach: Direct parsing without external dependencies
 */
function parseYamlSimple(content: string): Manifest {
  const lines = content.split('\n');
  const result: any = {};
  const stack: { indent: number; obj: any; key: string }[] = [{ indent: -1, obj: result, key: '' }];

  for (const line of lines) {
    // Skip comments and empty lines
    if (line.trim().startsWith('#') || line.trim() === '') continue;

    const indent = line.search(/\S/);
    const trimmed = line.trim();

    // Handle list items
    if (trimmed.startsWith('- ')) {
      const value = trimmed.slice(2).trim().replace(/^["']|["']$/g, '');
      const parent = stack[stack.length - 1];
      if (!Array.isArray(parent.obj[parent.key])) {
        parent.obj[parent.key] = [];
      }
      parent.obj[parent.key].push(value);
      continue;
    }

    // Handle key-value pairs
    const colonIdx = trimmed.indexOf(':');
    if (colonIdx === -1) continue;

    const key = trimmed.slice(0, colonIdx).trim();
    let value = trimmed.slice(colonIdx + 1).trim();

    // Pop stack to correct level
    while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
      stack.pop();
    }

    const parent = stack[stack.length - 1].obj;

    if (value === '' || value === '|') {
      // Nested object
      parent[key] = {};
      stack.push({ indent, obj: parent, key });
    } else {
      // Parse value
      value = value.replace(/^["']|["']$/g, '');
      if (value === 'true') parent[key] = true;
      else if (value === 'false') parent[key] = false;
      else if (!isNaN(Number(value))) parent[key] = Number(value);
      else parent[key] = value;
    }
  }

  return result as Manifest;
}

/**
 * Generate TypeScript type definitions
 */
function generateTypes(manifest: Manifest): GeneratedFile {
  const content = `/**
 * Generated Types - Vyberology 2.0
 * Generated by: ${GENERATOR}
 * Manifest version: ${manifest.version}
 *
 * DO NOT EDIT - This file is auto-generated
 */

// ============================================================================
// FREQUENCY BANDS
// ============================================================================

export type FrequencyBand = 'critical' | 'low' | 'nominal' | 'optimal' | 'peak';

export interface FrequencyThresholds {
  critical: number;
  low: number;
  nominal: number;
  optimal: number;
}

// ============================================================================
// COMPONENT WEIGHTS
// ============================================================================

export interface ComponentWeights {
  A3_governance: number;
  A4_architecture: number;
  A5_implementation: number;
  validation: number;
}

// ============================================================================
// VALIDATION LEVELS
// ============================================================================

export type ValidationLevel = ${manifest.thunder_strike?.validation_levels?.map(l => `'${l}'`).join(' | ') || "'self_assessment' | 'peer_review' | 'external_validation' | 'diamond_hands_final'"};

// ============================================================================
// METRICS
// ============================================================================

export type MetricName = ${Object.keys(manifest.metrics || {}).map(k => `'${k}'`).join(' | ') || "'coherence' | 'alignment' | 'velocity' | 'stability' | 'evidence_score'"};

export interface MetricDefinition {
  name: MetricName;
  description: string;
  weight: number;
  sources: string[];
}

// ============================================================================
// ROLES
// ============================================================================

export type RoleCode = 'B-01' | 'B-02' | 'B-03' | 'B-04' | 'B-05' | 'B-06' | 'B-07';

export interface RoleAssignment {
  code: RoleCode;
  name: string;
  assignee: string;
  category: 'owner' | 'validator' | 'authority';
}

// ============================================================================
// EVIDENCE
// ============================================================================

export type EvidenceFormat = ${manifest.evidence?.formats?.map(f => `'${f}'`).join(' | ') || "'json' | 'yaml' | 'markdown'"};

export type RequiredArtifact = ${manifest.evidence?.required_artifacts?.map(a => `'${a}'`).join(' | ') || "'frequency_report' | 'validation_logs' | 'component_metrics' | 'decision_record'"};

// ============================================================================
// PROJECT CONFIG
// ============================================================================

export interface ProjectConfig {
  name: string;
  description: string;
  repository: string;
  version: string;
}

// ============================================================================
// NOTIFICATION EVENTS
// ============================================================================

export type NotificationEvent = 'band_change' | 'validation_failed' | 'diamond_hands_ready' | 'critical_frequency' | 'poc_advancement';

export type NotificationChannel = 'slack' | 'email';
`;

  return {
    path: 'types.ts',
    content,
    hash: generateHash(content),
    type: 'types'
  };
}

/**
 * Generate constants from manifest
 */
function generateConstants(manifest: Manifest): GeneratedFile {
  const thresholds = manifest.thresholds || { critical: 0.3, low: 0.5, nominal: 0.7, optimal: 0.9 };
  const weights = manifest.weights || { A3_governance: 0.3, A4_architecture: 0.25, A5_implementation: 0.25, validation: 0.2 };

  const content = `/**
 * Generated Constants - Vyberology 2.0
 * Generated by: ${GENERATOR}
 *
 * DO NOT EDIT - This file is auto-generated
 */

import type {
  FrequencyThresholds,
  ComponentWeights,
  ValidationLevel,
  MetricDefinition,
  ProjectConfig,
  EvidenceFormat,
  RequiredArtifact
} from './types';

// ============================================================================
// PROJECT
// ============================================================================

export const PROJECT: ProjectConfig = {
  name: '${manifest.project?.name || 'LUMEN OS'}',
  description: '${manifest.project?.description || 'Governance + Validation System'}',
  repository: '${manifest.project?.repository || ''}',
  version: '${manifest.version || '2.0.0'}'
} as const;

// ============================================================================
// FREQUENCY THRESHOLDS
// ============================================================================

export const THRESHOLDS: FrequencyThresholds = {
  critical: ${thresholds.critical},
  low: ${thresholds.low},
  nominal: ${thresholds.nominal},
  optimal: ${thresholds.optimal}
} as const;

// ============================================================================
// COMPONENT WEIGHTS
// ============================================================================

export const WEIGHTS: ComponentWeights = {
  A3_governance: ${weights.A3_governance},
  A4_architecture: ${weights.A4_architecture},
  A5_implementation: ${weights.A5_implementation},
  validation: ${weights.validation}
} as const;

// ============================================================================
// VALIDATION LEVELS
// ============================================================================

export const VALIDATION_LEVELS: readonly ValidationLevel[] = [
${(manifest.thunder_strike?.validation_levels || ['self_assessment', 'peer_review', 'external_validation', 'diamond_hands_final']).map(l => `  '${l}'`).join(',\n')}
] as const;

export const REQUIRED_FOR_ADVANCEMENT: readonly ValidationLevel[] = [
${(manifest.thunder_strike?.required_for_advancement || ['self_assessment', 'peer_review', 'external_validation']).map(l => `  '${l}'`).join(',\n')}
] as const;

// ============================================================================
// DIAMOND HANDS CONFIGURATION
// ============================================================================

export const DIAMOND_HANDS = {
  threshold: ${manifest.diamond_hands?.threshold || 0.7},
  requiredValidationScore: ${manifest.diamond_hands?.required_validation_score || 0.8},
  approvalRequired: ${manifest.diamond_hands?.approval_required ?? true},
  approvers: [${(manifest.diamond_hands?.approvers || []).map(a => `'${a}'`).join(', ')}]
} as const;

// ============================================================================
// METRICS DEFINITIONS
// ============================================================================

export const METRICS: Record<string, MetricDefinition> = {
${Object.entries(manifest.metrics || {}).map(([key, val]: [string, any]) => `  ${key}: {
    name: '${key}',
    description: '${val.description || ''}',
    weight: ${val.weight || 0},
    sources: [${(val.sources || []).map((s: string) => `'${s}'`).join(', ')}]
  }`).join(',\n')}
} as const;

// ============================================================================
// EVIDENCE CONFIGURATION
// ============================================================================

export const EVIDENCE = {
  outputDirectory: '${manifest.evidence?.output_directory || 'evidence/A7-bundle'}',
  formats: [${(manifest.evidence?.formats || ['json', 'yaml', 'markdown']).map(f => `'${f}'`).join(', ')}] as EvidenceFormat[],
  retentionDays: ${manifest.evidence?.retention_days || 90},
  requiredArtifacts: [${(manifest.evidence?.required_artifacts || []).map(a => `'${a}'`).join(', ')}] as RequiredArtifact[]
} as const;

// ============================================================================
// CI CONFIGURATION
// ============================================================================

export const CI = {
  triggerOn: [${(manifest.ci?.trigger_on || ['push', 'pull_request']).map(t => `'${t}'`).join(', ')}],
  schedule: '${manifest.ci?.schedule || '0 */6 * * *'}'
} as const;
`;

  return {
    path: 'constants.ts',
    content,
    hash: generateHash(content),
    type: 'constants'
  };
}

/**
 * Generate validators
 */
function generateValidators(manifest: Manifest): GeneratedFile {
  const thresholds = manifest.thresholds || { critical: 0.3, low: 0.5, nominal: 0.7, optimal: 0.9 };

  const content = `/**
 * Generated Validators - Vyberology 2.0
 * Generated by: ${GENERATOR}
 *
 * DO NOT EDIT - This file is auto-generated
 */

import type { FrequencyBand, ValidationLevel, MetricName } from './types';
import { THRESHOLDS, WEIGHTS, DIAMOND_HANDS, VALIDATION_LEVELS } from './constants';

// ============================================================================
// FREQUENCY CLASSIFICATION
// ============================================================================

/**
 * Classify frequency into operational band
 */
export function classifyFrequency(fTotal: number): FrequencyBand {
  if (fTotal < ${thresholds.critical}) return 'critical';
  if (fTotal < ${thresholds.low}) return 'low';
  if (fTotal < ${thresholds.nominal}) return 'nominal';
  if (fTotal < ${thresholds.optimal}) return 'optimal';
  return 'peak';
}

/**
 * Check if frequency meets Diamond Hands threshold
 */
export function isDiamondHandsReady(fTotal: number, validationScore: number): boolean {
  return fTotal >= DIAMOND_HANDS.threshold &&
         validationScore >= DIAMOND_HANDS.requiredValidationScore;
}

// ============================================================================
// VALIDATION CHECKS
// ============================================================================

/**
 * Check if validation level is required for advancement
 */
export function isValidationRequired(level: ValidationLevel): boolean {
  return (VALIDATION_LEVELS as readonly string[]).includes(level);
}

/**
 * Validate metric value is in range
 */
export function isValidMetricValue(value: number): boolean {
  return value >= 0 && value <= 1;
}

/**
 * Validate weights sum to 1.0
 */
export function validateWeights(): boolean {
  const sum = WEIGHTS.A3_governance +
              WEIGHTS.A4_architecture +
              WEIGHTS.A5_implementation +
              WEIGHTS.validation;
  return Math.abs(sum - 1.0) < 0.001;
}

// ============================================================================
// FREQUENCY CALCULATION
// ============================================================================

export interface ComponentMetrics {
  coherence: number;
  alignment: number;
  velocity: number;
  stability: number;
  evidenceScore: number;
}

/**
 * Calculate component frequency from metrics
 */
export function calculateComponentFrequency(metrics: ComponentMetrics): number {
  return (
    metrics.coherence * 0.25 +
    metrics.alignment * 0.25 +
    metrics.velocity * 0.15 +
    metrics.stability * 0.20 +
    metrics.evidenceScore * 0.15
  );
}

/**
 * Calculate total frequency from component frequencies
 */
export function calculateFTotal(
  components: number[],
  validationPassRate: number
): number {
  if (components.length === 0) return 0;

  const rawFTotal = components.reduce((a, b) => a + b, 0) / components.length;
  const validationMultiplier = 0.8 + (0.2 * validationPassRate);

  return rawFTotal * validationMultiplier;
}

// ============================================================================
// ACTION RECOMMENDATIONS
// ============================================================================

export type ActionRecommendation =
  | 'HALT'
  | 'CAUTION'
  | 'PROCEED'
  | 'ADVANCE'
  | 'EXECUTE';

/**
 * Get action recommendation based on frequency band
 */
export function getRecommendation(band: FrequencyBand): ActionRecommendation {
  switch (band) {
    case 'critical': return 'HALT';
    case 'low': return 'CAUTION';
    case 'nominal': return 'PROCEED';
    case 'optimal': return 'ADVANCE';
    case 'peak': return 'EXECUTE';
  }
}

/**
 * Get recommendation message
 */
export function getRecommendationMessage(band: FrequencyBand): string {
  switch (band) {
    case 'critical':
      return 'HALT: System requires immediate attention. Do not proceed with POC.';
    case 'low':
      return 'CAUTION: Address deficiencies before Thunder Strike review.';
    case 'nominal':
      return 'PROCEED: System stable. Continue with validation pipeline.';
    case 'optimal':
      return 'ADVANCE: Ready for Diamond Hands review.';
    case 'peak':
      return 'EXECUTE: Maximum coherence achieved. Full speed ahead.';
  }
}
`;

  return {
    path: 'validators.ts',
    content,
    hash: generateHash(content),
    type: 'validators'
  };
}

/**
 * Generate runtime config
 */
function generateConfig(manifest: Manifest): GeneratedFile {
  const content = `/**
 * Generated Runtime Config - Vyberology 2.0
 * Generated by: ${GENERATOR}
 *
 * DO NOT EDIT - This file is auto-generated
 */

import { PROJECT, THRESHOLDS, WEIGHTS, DIAMOND_HANDS, EVIDENCE, CI } from './constants';
import type { FrequencyBand, ValidationLevel } from './types';
import { classifyFrequency, isDiamondHandsReady, getRecommendation, getRecommendationMessage } from './validators';

// ============================================================================
// RUNTIME CONFIG OBJECT
// ============================================================================

export const config = {
  project: PROJECT,
  thresholds: THRESHOLDS,
  weights: WEIGHTS,
  diamondHands: DIAMOND_HANDS,
  evidence: EVIDENCE,
  ci: CI,

  // Utility methods
  classifyFrequency,
  isDiamondHandsReady,
  getRecommendation,
  getRecommendationMessage
} as const;

// ============================================================================
// FREQUENCY REPORT GENERATOR
// ============================================================================

export interface FrequencyReport {
  timestamp: string;
  fTotal: number;
  band: FrequencyBand;
  diamondHandsReady: boolean;
  recommendation: string;
}

export function generateFrequencyReport(
  fTotal: number,
  validationScore: number
): FrequencyReport {
  const band = classifyFrequency(fTotal);

  return {
    timestamp: new Date().toISOString(),
    fTotal,
    band,
    diamondHandsReady: isDiamondHandsReady(fTotal, validationScore),
    recommendation: getRecommendationMessage(band)
  };
}

// ============================================================================
// EXPORT DEFAULT
// ============================================================================

export default config;
`;

  return {
    path: 'config.ts',
    content,
    hash: generateHash(content),
    type: 'config'
  };
}

/**
 * Generate barrel index file
 */
function generateIndex(files: GeneratedFile[]): GeneratedFile {
  const exports = files
    .filter(f => f.path !== 'index.ts')
    .map(f => {
      const moduleName = f.path.replace('.ts', '');
      return `export * from './${moduleName}';`;
    })
    .join('\n');

  const content = `/**
 * Vyberology 2.0 Generated Code
 * Generated by: ${GENERATOR}
 *
 * DO NOT EDIT - This file is auto-generated
 */

${exports}

// Default export
export { default as config } from './config';
`;

  return {
    path: 'index.ts',
    content,
    hash: generateHash(content),
    type: 'index'
  };
}

// ============================================================================
// HASHING UTILITIES
// ============================================================================

function generateHash(content: string): string {
  return crypto.createHash('sha256').update(content).digest('hex').slice(0, 16);
}

function generateOutputHash(output: Omit<CodegenOutput, 'hash'>): string {
  const content = JSON.stringify({
    files: output.files.map(f => ({ path: f.path, hash: f.hash })),
    manifestHash: output.metadata.manifestHash
  });
  return generateHash(content);
}
